from qgis.core import (
    QgsProcessingAlgorithm,
    QgsProcessingParameterPoint,
    QgsProcessingParameterNumber,
    QgsProcessingParameterEnum,
    QgsProcessingParameterFeatureSink,
    QgsProcessingParameterString,
    QgsProcessingParameterBoolean,
    QgsGeometry,
    QgsFeature,
    QgsField,
    QgsFields,
    QgsProject,
    QgsWkbTypes,
    QgsVectorLayer,
    QgsSpatialIndex,
    QgsFeatureRequest,
    QgsPointXY,
    QgsCoordinateReferenceSystem,
    QgsFeatureSink,
    QgsProcessing,
    QgsCoordinateTransform
)
from qgis.PyQt.QtCore import QVariant, QCoreApplication  
from qgis.analysis import (
    QgsVectorLayerDirector,
    QgsNetworkSpeedStrategy,
    QgsGraphBuilder,
    QgsGraphAnalyzer
)
import processing
import time
import re
import math
import heapq
import traceback
from collections import defaultdict


class IsochronePTStage3ConvexHull(QgsProcessingAlgorithm):

    SOURCE_POINT = 'SOURCE_POINT'
    TIME_INTERVAL = 'TIME_INTERVAL'
    STEPS = 'STEPS'
    WALK_SPEED = 'WALK_SPEED'
    WALK_SPEED_FIELD = 'WALK_SPEED_FIELD'
    BUS_SPEED = 'BUS_SPEED'
    ROUTE_FILTER = 'ROUTE_FILTER'
    SNAP_DIST = 'SNAP_DIST'
    TRANSFER_DIST = 'TRANSFER_DIST'
    BUFFER_ROUTE = 'BUFFER_ROUTE'
    VERTEX_SEARCH_RADIUS = 'VERTEX_SEARCH_RADIUS'
    OUTPUT = 'OUTPUT'

    def createInstance(self):
        return IsochronePTStage3ConvexHull()

    def name(self):
        return 'isochrone_pt_stage3_convex_hull'

    def displayName(self):
        return self.tr('Изохрона: Этап 3 (convex hull, финал)')

    def group(self):
        return self.tr('Доступность')

    def groupId(self):
        return 'accessibility'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def initAlgorithm(self, config=None):
        self.addParameter(QgsProcessingParameterPoint(self.SOURCE_POINT, self.tr('Точка старта'), optional=False))
        self.addParameter(QgsProcessingParameterNumber(self.TIME_INTERVAL, self.tr('Шаг времени (мин)'),
                                                      type=QgsProcessingParameterNumber.Double, defaultValue=5.0, minValue=1.0))
        self.addParameter(QgsProcessingParameterNumber(self.STEPS, self.tr('Количество шагов'),
                                                      type=QgsProcessingParameterNumber.Integer, defaultValue=4, minValue=1))
        self.addParameter(QgsProcessingParameterNumber(self.WALK_SPEED, self.tr('Скорость пешехода (км/ч)'),
                                                      type=QgsProcessingParameterNumber.Double, defaultValue=5.0, minValue=0.5))
        self.addParameter(QgsProcessingParameterNumber(self.BUS_SPEED, self.tr('Скорость ОТ (км/ч, если нет TRAVELTIME)'),
                                                      type=QgsProcessingParameterNumber.Double, defaultValue=25.0, minValue=5.0))
        self.addParameter(QgsProcessingParameterEnum(self.ROUTE_FILTER, self.tr('Фильтр по типу маршрута'),
                                                    options=[self.tr('Все'), self.tr('Только автобусы'), self.tr('Только трамваи')],
                                                    defaultValue=0))
        self.addParameter(QgsProcessingParameterNumber(self.SNAP_DIST, self.tr('Snap distance (m)'),
                                                      type=QgsProcessingParameterNumber.Double, defaultValue=25.0, minValue=1.0))
        self.addParameter(QgsProcessingParameterNumber(self.TRANSFER_DIST, self.tr('Transfer distance (m)'),
                                                      type=QgsProcessingParameterNumber.Double, defaultValue=150.0, minValue=10.0))
        self.addParameter(QgsProcessingParameterNumber(self.BUFFER_ROUTE, self.tr('Buffer along route (m) — для визуализации путей'),
                                                      type=QgsProcessingParameterNumber.Double, defaultValue=10.0, minValue=1.0))
        self.addParameter(QgsProcessingParameterNumber(self.VERTEX_SEARCH_RADIUS, self.tr('Vertex search radius (m)'),
                                                      type=QgsProcessingParameterNumber.Double, defaultValue=200.0, minValue=10.0))
        # Опциональное имя поля скорости пешехода (км/ч) в слое дорог; если пусто — используется единая скорость WALK_SPEED
        self.addParameter(QgsProcessingParameterString(self.WALK_SPEED_FIELD,
                                                       self.tr('Поле скорости пешехода в слое дорог (км/ч, опционально)'),
                                                       defaultValue='',
                                                       optional=True))
        self.addParameter(QgsProcessingParameterFeatureSink(self.OUTPUT, self.tr('Изохроны (сплошные полигоны)'),
                                                          type=QgsProcessing.TypeVectorPolygon))
        self.addParameter(QgsProcessingParameterBoolean(
            'USE_SLOPE', self.tr('Учитывать рельеф при расчёте пешеходной скорости'),
            defaultValue=True, optional=False
        ))

    def _parse_headway(self, headway_raw):
        """Парсит интервал движения (HEADWAY) из строки/числа → возвращает секунды."""
        if headway_raw is None:
            return None
        if isinstance(headway_raw, (int, float)):
            return float(headway_raw)
        s = str(headway_raw).strip().replace(',', '.').lower()
        nums = re.findall(r'[-+]?\d*\.?\d+', s)
        if not nums:
            return None
        val = float(nums[0])
        if any(kw in s for kw in ['мин', 'min', 'm', 'minutes']):
            val *= 60.0
        return val

    def _build_elevation_index(self, layer, context, feedback):
        """Строит spatial index и кэш высот по полигонам SRTM (используем MAX как высоту)."""
        # Приведём к CRS дорог (EPSG:3857), как в остальных слоях
        target_crs = QgsCoordinateReferenceSystem('EPSG:3857')
        if layer.crs() != target_crs:
            feedback.pushInfo("   Репроекция слоя высот в EPSG:3857...")
            layer = processing.run("native:reprojectlayer", {
                'INPUT': layer,
                'TARGET_CRS': target_crs,
                'OUTPUT': 'memory:'
            }, context=context, feedback=feedback)['OUTPUT']

        index = QgsSpatialIndex()
        cache = {}  # fid → height (м)
        for f in layer.getFeatures():
            geom = f.geometry()
            if not geom or geom.isEmpty():
                continue
            # Берём MAX как характерную высоту полигона
            h = f.attribute('MAX')
            if h is None:
                h = f.attribute('VALUE')  # fallback
            if h is None:
                continue
            try:
                h = float(h)
            except (ValueError, TypeError):
                continue
            cache[f.id()] = h
            index.addFeature(f)
        feedback.pushInfo(f"   ✔ Индекс высот: {len(cache)} полигонов")
        return index, cache

    def _get_elevation(self, point, index, cache, search_radius=100.0):
        """Возвращает высоту в метрах для QgsPointXY или None."""
        if index is None or cache is None:
            return None
        fids = index.nearestNeighbor(point, 1)
        if not fids:
            return None
        return cache.get(fids[0])

    def _tobler_speed_mps(self, slope):
        """
        Скорость по формуле Tobler (km/h → m/s), с ограничением.
        slope = dh / dx (м/м)
        """
        if slope is None:
            slope = 0.0
        v_kmh = 6.0 * math.exp(-3.5 * abs(slope + 0.05))
        v_kmh = max(0.5, min(8.0, v_kmh))  # ограничим разумно
        return v_kmh * 1000.0 / 3600.0

    def _process_line_segments(self, pts, edges_by_node, node_coords, 
                               elevation_index, elevation_cache, 
                               use_slope, walk_speed_mps, flat_tobler_speed,
                               feature_speed_mps=None):
        """
        Обрабатывает сегменты линии и добавляет их в граф.
        Возвращает количество обработанных сегментов.
        """
        segments = 0
        for i in range(len(pts) - 1):
            p1, p2 = pts[i], pts[i + 1]
            length = p1.distance(p2)
            if length < 0.1:
                continue

            key1 = (round(p1.x(), 3), round(p1.y(), 3))
            key2 = (round(p2.x(), 3), round(p2.y(), 3))
            node_coords.setdefault(key1, p1)
            node_coords.setdefault(key2, p2)

            # Выбираем базовую скорость (из поля или глобальную)
            base_speed = feature_speed_mps if feature_speed_mps and feature_speed_mps > 0 else walk_speed_mps

            # Получаем высоты
            h1 = self._get_elevation(p1, elevation_index, elevation_cache) if use_slope else None
            h2 = self._get_elevation(p2, elevation_index, elevation_cache) if use_slope else None

            if h1 is not None and h2 is not None:
                slope = (h2 - h1) / length if length > 0 else 0.0
                slope_speed = self._tobler_speed_mps(slope)
                factor = (slope_speed / flat_tobler_speed) if flat_tobler_speed > 0 else 1.0
                speed_mps = max(0.3, base_speed * factor)
            else:
                speed_mps = base_speed  # fallback

            time_sec = length / speed_mps

            # Двусторонний граф
            edges_by_node[key1].append((key2, time_sec))
            edges_by_node[key2].append((key1, time_sec))
            segments += 1
        
        return segments

    def _parse_numeric_value(self, value):
        if value is None:
            return None
        if isinstance(value, (int, float)):
            try:
                return float(value)
            except (TypeError, ValueError):
                return None
        s = str(value).strip()
        if not s:
            return None
        s = s.replace(',', '.')
        nums = re.findall(r'[-+]?\d*\.?\d+', s)
        if not nums:
            return None
        try:
            return float(nums[0])
        except (TypeError, ValueError):
            return None

    def _parse_speed_value(self, raw_value):
        val = self._parse_numeric_value(raw_value)
        if val is None or val <= 0:
            return None
        if isinstance(raw_value, str):
            s = raw_value.lower()
            if 'm/s' in s or 'м/с' in s:
                return val
            if 'km' in s or 'км' in s:
                return val * 1000.0 / 3600.0
        # Без единиц считаем, что указано в км/ч
        return val * 1000.0 / 3600.0

    def _extract_line_parts(self, geom):
        if geom is None or geom.isEmpty() or geom.type() != QgsWkbTypes.LineGeometry:
            return []
        if geom.isMultipart():
            try:
                return [[QgsPointXY(pt) for pt in line] for line in geom.asMultiPolyline() if len(line) >= 2]
            except Exception:
                return []
        try:
            line = geom.asPolyline()
            if len(line) < 2:
                return []
            return [[QgsPointXY(pt) for pt in line]]
        except Exception:
            return []

    def _extract_track_speed(self, feature, geom_length):
        if geom_length is None or geom_length <= 0.1:
            return None
        duration_fields = ['life_time', 'fly_time', 'duration', 'time', 'minutes', 'минут']
        for field in duration_fields:
            if feature.fields().indexOf(field) == -1:
                continue
            seconds = self._parse_numeric_value(feature.attribute(field))
            if seconds and seconds > 0:
                return geom_length / seconds
        for field in ['speed', 'speed_1', 'speed2']:
            if feature.fields().indexOf(field) == -1:
                continue
            speed_val = self._parse_numeric_value(feature.attribute(field))
            if speed_val and speed_val > 0:
                # Если значение большое, вероятно км/ч
                if speed_val > 40:
                    return speed_val * 1000.0 / 3600.0
                return speed_val
        return None

    def _build_route_track_segments(self, tracks_layer, crs, route_geoms, route_index, feedback):
        if tracks_layer is None:
            feedback.pushWarning("Слой 'Треки ОТ' не найден — скорости маршрутов из треков не используются")
            return {}
        transform = None
        if tracks_layer.crs() != crs:
            transform = QgsCoordinateTransform(tracks_layer.crs(), crs, QgsProject.instance())
        track_segments = defaultdict(list)
        total_tracks = tracks_layer.featureCount()
        processed = 0
        for tf in tracks_layer.getFeatures():
            processed += 1
            if processed % 10000 == 0:
                feedback.pushInfo(f"   Обработка треков: {processed}/{total_tracks}")
            geom = tf.geometry()
            if not geom or geom.isEmpty():
                continue
            try:
                geom = QgsGeometry(geom)
                if transform:
                    geom.transform(transform)
            except Exception:
                continue
            parts = self._extract_line_parts(geom)
            if not parts:
                continue
            for line in parts:
                line_geom = QgsGeometry.fromPolylineXY(line)
                length = line_geom.length()
                if length < 5.0:
                    continue
                speed_mps = self._extract_track_speed(tf, length)
                if not speed_mps or speed_mps <= 0:
                    continue
                centroid = line_geom.centroid().asPoint()
                cand_ids = route_index.nearestNeighbor(centroid, 5)
                best_rid = None
                best_dist = float('inf')
                for rid in cand_ids:
                    route_geom = route_geoms.get(rid)
                    if route_geom is None:
                        continue
                    try:
                        d = route_geom.distance(line_geom)
                    except Exception:
                        d = float('inf')
                    if d < best_dist:
                        best_dist = d
                        best_rid = rid
                if best_rid is None or best_dist > 50.0:
                    continue
                route_geom = route_geoms[best_rid]
                try:
                    start_measure = route_geom.lineLocatePoint(QgsGeometry.fromPointXY(line[0]))
                    end_measure = route_geom.lineLocatePoint(QgsGeometry.fromPointXY(line[-1]))
                except Exception:
                    continue
                if math.isinf(start_measure) or math.isinf(end_measure):
                    continue
                seg_start = min(start_measure, end_measure)
                seg_end = max(start_measure, end_measure)
                if seg_end - seg_start < 5.0:
                    continue
                track_segments[best_rid].append((seg_start, seg_end, speed_mps))
        if track_segments:
            total_entries = sum(len(v) for v in track_segments.values())
            feedback.pushInfo(f"   ✔ Получены скоростные интервалы для {len(track_segments)} маршрутов ({total_entries} отрезков)")
        else:
            feedback.pushWarning("Не удалось сопоставить треки маршрутам — используется скорость BUS_SPEED/TRAVELTIME")
        return track_segments

    def _estimate_segment_speed_from_tracks(self, rid, measure_a, measure_b, track_segments):
        seg_data = track_segments.get(rid)
        if not seg_data:
            return None
        a = min(measure_a, measure_b)
        b = max(measure_a, measure_b)
        if b - a < 1.0:
            return None
        total = 0.0
        weight = 0.0
        for ts, te, speed in seg_data:
            overlap_start = max(a, ts)
            overlap_end = min(b, te)
            overlap = overlap_end - overlap_start
            if overlap > 0.5:
                total += speed * overlap
                weight += overlap
        if weight > 0:
            return total / weight
        return None

    def _shortest_walk_time_between_nodes(self, start_key, end_key, edges_by_node, max_time):
        if start_key is None or end_key is None:
            return None
        heap = [(0.0, start_key)]
        visited = set()
        while heap:
            cost, node = heapq.heappop(heap)
            if cost > max_time:
                continue
            if node == end_key:
                return cost
            if node in visited:
                continue
            visited.add(node)
            for nxt, weight in edges_by_node.get(node, []):
                new_cost = cost + weight
                if new_cost <= max_time:
                    heapq.heappush(heap, (new_cost, nxt))
        return None

    def _compute_transfer_walk_time(self, stop_a, stop_b, stop_node_info, edges_by_node,
                                    walk_speed_mps, transfer_dist, direct_distance):
        info_a = stop_node_info.get(stop_a)
        info_b = stop_node_info.get(stop_b)
        if info_a and info_b and info_a[0] and info_b[0]:
            max_time = (transfer_dist * 3.0) / max(walk_speed_mps, 0.1)
            network_time = self._shortest_walk_time_between_nodes(info_a[0], info_b[0], edges_by_node, max_time)
            if network_time is not None:
                offset_time = 0.0
                if info_a[1]:
                    offset_time += info_a[1] / max(walk_speed_mps, 0.1)
                if info_b[1]:
                    offset_time += info_b[1] / max(walk_speed_mps, 0.1)
                return network_time + offset_time
        return direct_distance / walk_speed_mps

    def processAlgorithm(self, parameters, context, feedback):
        t_total = time.time()
        feedback.pushInfo("Этап 3 (convex hull, финал): старт — построение СПЛОШНЫХ изохрон")

        # --- Шаг 1: Чтение параметров ---
        start_point = self.parameterAsPoint(parameters, self.SOURCE_POINT, context)
        time_interval = self.parameterAsDouble(parameters, self.TIME_INTERVAL, context)
        steps = self.parameterAsInt(parameters, self.STEPS, context)
        walk_speed_kmh = self.parameterAsDouble(parameters, self.WALK_SPEED, context)
        bus_speed_kmh = self.parameterAsDouble(parameters, self.BUS_SPEED, context)
        route_filter = self.parameterAsEnum(parameters, self.ROUTE_FILTER, context)
        snap_dist = self.parameterAsDouble(parameters, self.SNAP_DIST, context)
        transfer_dist = self.parameterAsDouble(parameters, self.TRANSFER_DIST, context)
        vertex_search_radius = self.parameterAsDouble(parameters, self.VERTEX_SEARCH_RADIUS, context)
        walk_speed_field = self.parameterAsString(parameters, self.WALK_SPEED_FIELD, context).strip()

        walk_speed_mps = walk_speed_kmh * 1000.0 / 3600.0
        bus_speed_mps = bus_speed_kmh * 1000.0 / 3600.0

        # --- Шаг 2: Получение слоёв из проекта ---
        project = context.project() if context.project() else QgsProject.instance()
        if not project:
            raise Exception("Не удалось получить проект.")

        names = {
            'roads': 'исправленные пешеходные графы',
            'stops': 'ООТ_stoppoint_stoppoint',
            'routes': 'Маршруты_ОТ_lineRoute',
            'buildings': 'Здания_насел_attract',
            'elevation_poly': 'SRTM_Irkutsk_Poligon_Interval_1'
        }
        layers = {}
        for key, name in names.items():
            cands = project.mapLayersByName(name)
            if not cands:
                all_names = [lyr.name() for lyr in project.mapLayers().values()]
                feedback.reportError(f"Доступные слои: {all_names}")
                raise Exception(f"Слой '{name}' не найден.")
            layers[key] = cands[0]
            feedback.pushInfo(f"'{name}': {layers[key].featureCount()} объектов")

        roads_layer = layers['roads']
        stops_layer = layers['stops']
        routes_layer = layers['routes']
        buildings_layer = layers['buildings']

        tracks_layer = None
        track_candidates = project.mapLayersByName('Треки ОТ')
        if track_candidates:
            tracks_layer = track_candidates[0]
            feedback.pushInfo(f"'Треки ОТ': {tracks_layer.featureCount()} объектов")
        else:
            feedback.pushWarning(" Слой 'Треки ОТ' не найден — скорости маршрутов по трекам не будут учтены")

        crs = roads_layer.crs()
        feedback.pushInfo(f" CRS расчёта: {crs.authid()}")
        feedback.pushInfo(f" Старт: X={start_point.x():.3f}, Y={start_point.y():.3f}")

        # --- Шаг 3: Подготовка слоёв ---
        t0 = time.time()
        feedback.pushInfo(" Подготовка слоёв...")

        roads_clean = processing.run("native:fixgeometries", {
            'INPUT': roads_layer,
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']

        stops_reproj = processing.run("native:reprojectlayer", {
            'INPUT': stops_layer,
            'TARGET_CRS': crs,
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']
        stops_points = processing.run("native:centroids", {
            'INPUT': stops_reproj,
            'ALL_PARTS': False,
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']

        routes_reproj = routes_layer
        if routes_layer.crs() != crs:
            routes_reproj = processing.run("native:reprojectlayer", {
                'INPUT': routes_layer,
                'TARGET_CRS': crs,
                'OUTPUT': 'memory:'
            }, context=context, feedback=feedback)['OUTPUT']

        buildings_reproj = buildings_layer
        if buildings_layer.crs() != crs:
            buildings_reproj = processing.run("native:reprojectlayer", {
                'INPUT': buildings_layer,
                'TARGET_CRS': crs,
                'OUTPUT': 'memory:'
            }, context=context, feedback=feedback)['OUTPUT']

        # --- Подготовка DEM (рельефа) ---
        elevation_layer = layers.get('elevation_poly')
        elevation_index = elevation_cache = None
        if elevation_layer:
            try:
                elevation_index, elevation_cache = self._build_elevation_index(
                    elevation_layer, context, feedback
                )
            except Exception as e:
                feedback.pushWarning(f" Ошибка при построении индекса высот: {e}")
        else:
            feedback.pushWarning(" Слой высот 'SRTM_Irkutsk_Poligon_Interval_1' не найден — рельеф игнорируется")

        # Чтение параметра
        use_slope = self.parameterAsBoolean(parameters, 'USE_SLOPE', context)
        if use_slope and elevation_index is None:
            feedback.pushInfo("    Рельеф включён, но DEM недоступен → используется постоянная скорость")
            use_slope = False

        b_index = QgsSpatialIndex(buildings_reproj.getFeatures())
        feedback.pushInfo(f"   Подготовка слоёв завершена за {time.time() - t0:.2f} сек")

        # --- Шаг 4: Пешеходный граф (ручной, с учётом рельефа, если включено) ---
        t0 = time.time()
        feedback.pushInfo(" Построение пешего графа...")

        # Проверяем входной слой
        if roads_clean is None:
            raise Exception(" Слой roads_clean равен None")
        roads_count = roads_clean.featureCount()
        feedback.pushInfo(f"   Входной слой дорог: {roads_count} объектов")
        if roads_count == 0:
            raise Exception(" Слой дорог пуст - нет объектов для построения графа")

        # Извлекаем геометрию дорог напрямую (без использования processing.run)
        feedback.pushInfo("    Извлечение геометрии дорог напрямую (линии/полигоны)...")
        edges_by_node = defaultdict(list)  # (x_round, y_round) → [(to_key, time_sec), ...]
        node_coords = {}  # key → QgsPointXY

        total_features = roads_clean.featureCount()
        processed = 0
        line_segments = 0
        empty_geoms = 0
        wrong_type = 0
        boundary_empty = 0
        errors = 0
        walk_speed_field_idx = roads_clean.fields().indexOf(walk_speed_field) if walk_speed_field else -1
        flat_tobler_speed = self._tobler_speed_mps(0.0)

        for f in roads_clean.getFeatures():
            processed += 1
            if processed % 5000 == 0:
                feedback.setProgress(int(50 * processed / total_features))
                feedback.pushInfo(f"   Обработано {processed}/{total_features} объектов...")
            
            geom = f.geometry()
            if not geom or geom.isEmpty():
                empty_geoms += 1
                continue

            feature_speed_mps = None
            if walk_speed_field_idx != -1:
                feature_speed_mps = self._parse_speed_value(f.attribute(walk_speed_field))
            
            # Проверяем тип геометрии
            geom_type = geom.type()
            # Вариант 1: слой уже линейный (тип LineGeometry) — обрабатываем как линии
            if geom_type == QgsWkbTypes.LineGeometry:
                try:
                    if geom.isMultipart():
                        multi_line = geom.asMultiPolyline()
                        for line in multi_line:
                            if len(line) < 2:
                                continue
                            pts = [QgsPointXY(pt) for pt in line]
                            segs = self._process_line_segments(
                                pts, edges_by_node, node_coords,
                                elevation_index, elevation_cache,
                                use_slope, walk_speed_mps, flat_tobler_speed,
                                feature_speed_mps
                            )
                            line_segments += segs
                    else:
                        line = geom.asPolyline()
                        if len(line) >= 2:
                            pts = [QgsPointXY(pt) for pt in line]
                            segs = self._process_line_segments(
                                pts, edges_by_node, node_coords,
                                elevation_index, elevation_cache,
                                use_slope, walk_speed_mps, flat_tobler_speed,
                                feature_speed_mps
                            )
                            line_segments += segs
                except Exception as e:
                    errors += 1
                    if errors <= 3:
                        feedback.pushWarning(f"   Ошибка при обработке линейной геометрии объекта {f.id()}: {str(e)}")
                    continue

            # Вариант 2: полигональная геометрия — извлекаем границы полигонов (реже для данного слоя)
            if geom_type == QgsWkbTypes.PolygonGeometry:
                segments_added = 0
                try:
                    # Способ 1: Используем boundary()
                    boundary = geom.boundary()
                    if boundary and not boundary.isEmpty():
                        # Обрабатываем MultiLineString или LineString
                        if boundary.isMultipart():
                            # Разбиваем на отдельные линии
                            try:
                                multi_line = boundary.asMultiPolyline()
                                for line_ring in multi_line:
                                    if len(line_ring) < 2:
                                        continue
                                    pts = [QgsPointXY(pt) for pt in line_ring]
                                    segs = self._process_line_segments(
                                        pts, edges_by_node, node_coords, 
                                        elevation_index, elevation_cache, 
                                        use_slope, walk_speed_mps, flat_tobler_speed,
                                        feature_speed_mps
                                    )
                                    segments_added += segs
                                    line_segments += segs
                            except Exception as e:
                                if errors <= 3:
                                    feedback.pushWarning(f"   Ошибка MultiLineString: {str(e)}")
                                errors += 1
                        else:
                            # Одна линия
                            try:
                                line = boundary.asPolyline()
                                if len(line) >= 2:
                                    pts = [QgsPointXY(pt) for pt in line]
                                    segs = self._process_line_segments(
                                        pts, edges_by_node, node_coords,
                                        elevation_index, elevation_cache,
                                        use_slope, walk_speed_mps, flat_tobler_speed,
                                        feature_speed_mps
                                    )
                                    segments_added += segs
                                    line_segments += segs
                            except Exception as e:
                                if errors <= 3:
                                    feedback.pushWarning(f"   Ошибка LineString: {str(e)}")
                                errors += 1
                    
                    # Способ 2: Если boundary() не сработал, пробуем извлечь кольца напрямую
                    if segments_added == 0:
                        try:
                            # Пробуем получить полигон напрямую
                            if geom.isMultipart():
                                multi_poly = geom.asMultiPolygon()
                                for poly in multi_poly:
                                    # Обрабатываем внешнее кольцо и внутренние кольца
                                    for ring in poly:
                                        if len(ring) < 2:
                                            continue
                                        pts = [QgsPointXY(pt) for pt in ring]
                                        segs = self._process_line_segments(
                                            pts, edges_by_node, node_coords,
                                            elevation_index, elevation_cache,
                                            use_slope, walk_speed_mps, flat_tobler_speed,
                                            feature_speed_mps
                                        )
                                        segments_added += segs
                                        line_segments += segs
                            else:
                                poly = geom.asPolygon()
                                for ring in poly:
                                    if len(ring) < 2:
                                        continue
                                    pts = [QgsPointXY(pt) for pt in ring]
                                    segs = self._process_line_segments(
                                        pts, edges_by_node, node_coords,
                                        elevation_index, elevation_cache,
                                        use_slope, walk_speed_mps, flat_tobler_speed,
                                        feature_speed_mps
                                    )
                                    segments_added += segs
                                    line_segments += segs
                        except Exception as e:
                            if errors <= 3:
                                feedback.pushWarning(f"   Ошибка при прямом извлечении колец: {str(e)}")
                            errors += 1
                            boundary_empty += 1
                    
                except Exception as e:
                    errors += 1
                    if errors <= 3:
                        feedback.pushWarning(f"   Ошибка при извлечении границы объекта {f.id()}: {str(e)}")
                    continue

            # Вариант 3: геометрия другого типа — просто считаем как неправильный тип
            wrong_type += 1
            if wrong_type <= 5:
                feedback.pushInfo(f"   Объект {f.id()}: тип геометрии {geom_type}, ожидались линии/полигоны")
        
        # Выводим статистику
        feedback.pushInfo(f"   Статистика обработки:")
        feedback.pushInfo(f"      - Пустые геометрии: {empty_geoms}")
        feedback.pushInfo(f"      - Неправильный тип: {wrong_type}")
        feedback.pushInfo(f"      - Пустые границы: {boundary_empty}")
        feedback.pushInfo(f"      - Ошибки обработки: {errors}")
        
        feedback.setProgress(50)
        feedback.pushInfo(f"   ✔ Извлечено сегментов: {line_segments} из {processed} объектов")
        
        if line_segments == 0:
            raise Exception(" Не удалось извлечь ни одного сегмента из слоя дорог. Проверьте геометрию слоя.")
        
        if len(node_coords) == 0:
            raise Exception(" Граф пуст - нет узлов. Проверьте геометрию слоя дорог.")

        total_edges = sum(len(v) for v in edges_by_node.values()) // 2
        feedback.pushInfo(f"    Граф: узлов={len(node_coords)}, рёбер≈{total_edges} (за {time.time() - t0:.2f}s)")

        # Строим spatial index по узлам пешего графа для быстрого поиска ближайших
        t0_index = time.time()
        feedback.pushInfo(" Построение spatial index по узлам пешего графа...")
        walk_nodes_index = QgsSpatialIndex()
        node_fid_to_key = {}
        for idx, (key, pt) in enumerate(node_coords.items()):
            feat = QgsFeature(idx)
            feat.setGeometry(QgsGeometry.fromPointXY(pt))
            walk_nodes_index.addFeature(feat)
            node_fid_to_key[feat.id()] = key
        feedback.pushInfo(f"    Spatial index построен по {len(node_coords)} узлам за {time.time() - t0_index:.2f} сек")

        # --- Шаг 5: Привязка старта и Dijkstra по пешему графу ---
        t0 = time.time()
        feedback.pushInfo(" Запуск Dijkstra по пешему графу...")

        # Находим ближайший узел к start_point
        start_key = None
        min_d_to_start = float('inf')
        for key, pt in node_coords.items():
            d = pt.distance(start_point)
            if d < min_d_to_start:
                min_d_to_start = d
                start_key = key

        if start_key is None or min_d_to_start > 500:
            feedback.pushWarning(" Старт не привязан к графу — fallback на круги")
            fallback_mode = True
            dist_walk = None
        else:
            fallback_mode = False
            # Dijkstra по словарю
            dist_walk = {key: math.inf for key in node_coords}
            dist_walk[start_key] = 0.0
            heap = [(0.0, start_key)]
            visited = set()

            while heap:
                d, u = heapq.heappop(heap)
                if u in visited:
                    continue
                visited.add(u)
                for v, w in edges_by_node.get(u, []):
                    nd = d + w
                    if nd < dist_walk.get(v, math.inf):
                        dist_walk[v] = nd
                        heapq.heappush(heap, (nd, v))

            feedback.pushInfo(f"   Dijkstra завершён: {len(visited)} узлов, за {time.time() - t0:.2f} сек")

        # --- Шаг 6: Сбор остановок ---
        stop_pts = []
        stop_id_to_geom = {}
        for sf in stops_points.getFeatures():
            g = sf.geometry()
            if g and not g.isEmpty():
                pt = QgsPointXY(g.asPoint())
                stop_pts.append((sf.id(), pt))
                stop_id_to_geom[sf.id()] = pt
        total_stops = len(stop_pts)
        feedback.pushInfo(f" Всего остановок: {total_stops}")

        # --- Шаг 7: Индексация маршрутов и привязка ---
        t0 = time.time()
        feedback.pushInfo(" Индексация маршрутов и привязка остановок...")
        r_index = QgsSpatialIndex()
        route_geoms = {}
        route_headway = {}
        route_traveltime = {}
        route_length_m = {}
        route_type = {}
        valid_routes = []

        for rf in routes_reproj.getFeatures():
            tsys = rf.attribute('TSYSCODE')
            if route_filter == 1 and (tsys is None or str(tsys).upper() != 'A'):
                continue
            if route_filter == 2 and (tsys is None or str(tsys).upper() != 'T'):
                continue
            geom = rf.geometry()
            if geom is None or geom.isEmpty():
                continue
            rid = rf.id()
            route_geoms[rid] = geom
            r_index.addFeature(rf)
            route_type[rid] = tsys
            route_headway[rid] = self._parse_headway(rf.attribute('HEADWAY'))
            tt = rf.attribute('TRAVELTIME')
            route_traveltime[rid] = float(tt) if isinstance(tt, (int, float)) and tt > 0 else None
            ln_raw = rf.attribute('LENGTH')
            try:
                if isinstance(ln_raw, str) and 'km' in ln_raw.lower():
                    num = re.findall(r'[-+]?\d*\.?\d+', ln_raw)
                    route_length_m[rid] = float(num[0]) * 1000.0 if num else geom.length()
                else:
                    route_length_m[rid] = geom.length()
            except Exception:
                route_length_m[rid] = geom.length()
            valid_routes.append(rid)

        track_segments_by_route = self._build_route_track_segments(tracks_layer, crs, route_geoms, r_index, feedback)

        stops_route_map = defaultdict(list)
        for stop_id, pt in stop_pts:
            bbox = QgsGeometry.fromPointXY(pt).buffer(snap_dist, 6).boundingBox()
            cand_ids = r_index.intersects(bbox)
            best = None
            best_dist = float('inf')
            best_measure = None
            for rid in cand_ids:
                if rid not in valid_routes:
                    continue
                rg = route_geoms.get(rid)
                if rg is None:
                    continue
                d = rg.distance(QgsGeometry.fromPointXY(pt))
                if d <= snap_dist:
                    try:
                        measure = rg.lineLocatePoint(QgsGeometry.fromPointXY(pt))
                    except Exception:
                        continue
                    # Выбираем маршрут с МИНИМАЛЬНЫМ расстоянием до остановки
                    if d < best_dist:
                        best = rid
                        best_dist = d
                        best_measure = measure
            if best is not None:
                stops_route_map[best].append((stop_id, best_measure, pt))

        for rid, items in stops_route_map.items():
            items.sort(key=lambda x: x[1])

        bound_stops = sum(len(v) for v in stops_route_map.values())
        feedback.pushInfo(f"   Привязано остановок: {bound_stops} из {total_stops} (за {time.time() - t0:.2f}s)")

        # --- Шаг 8: Время пешком до остановок (с рельефом или без) ---
        walk_time_to_stop = {}
        stop_node_info = {}

        if not fallback_mode and dist_walk is not None:
            t0 = time.time()
            feedback.pushInfo(" Расчёт времени до остановок...")
            for stop_id, stop_pt in stop_pts:
                # Ближайший узел графа в радиусе с использованием spatial index
                best_key = None
                best_d = float('inf')
                try:
                    nearest_ids = walk_nodes_index.nearestNeighbor(stop_pt, 5)
                except Exception:
                    nearest_ids = []

                for fid in nearest_ids:
                    key = node_fid_to_key.get(fid)
                    if key is None:
                        continue
                    pt_node = node_coords.get(key)
                    if pt_node is None:
                        continue
                    d = pt_node.distance(stop_pt)
                    if d <= vertex_search_radius and d < best_d:
                        best_d = d
                        best_key = key

                if best_key is not None and best_key in dist_walk:
                    t = dist_walk[best_key]
                    # + пешком от узла до остановки (по прямой, константной скоростью)
                    t += best_d / walk_speed_mps
                    stop_node_info[stop_id] = (best_key, best_d)
                else:
                    # fallback: по прямой
                    t = stop_pt.distance(start_point) / walk_speed_mps
                    stop_node_info[stop_id] = (None, None)
                walk_time_to_stop[stop_id] = t
            feedback.pushInfo(f"   Время до остановок рассчитано за {time.time() - t0:.2f} сек")
        else:
            # Полный fallback: по прямой
            for stop_id, pt in stop_pts:
                walk_time_to_stop[stop_id] = pt.distance(start_point) / walk_speed_mps
                stop_node_info[stop_id] = (None, None)

        # --- Шаг 9: Мультиграф ---
        node_index = {stop_id: idx + 1 for idx, (stop_id, _) in enumerate(stop_pts)}
        nodes = [start_point] + [pt for (_, pt) in stop_pts]
        edges = defaultdict(list)

        # Посадка (start → остановка)
        for stop_id, pt in stop_pts:
            candidate_routes = [rid for rid, arr in stops_route_map.items() if any(sid == stop_id for sid, _, _ in arr)]
            if not candidate_routes:
                continue
            waits = [route_headway.get(rid, 600) for rid in candidate_routes if route_headway.get(rid)]
            wait_time = min(waits) / 2.0 if waits else 300.0
            walk_sec = walk_time_to_stop.get(stop_id, 0.0)
            total_board = walk_sec + wait_time
            edges[0].append((node_index[stop_id], total_board, 'board'))

        # Поездка (остановка → остановка)
        for rid, stops_seq in stops_route_map.items():
            if len(stops_seq) < 2:
                continue
            total_len = route_length_m.get(rid, route_geoms[rid].length())
            tt_route = route_traveltime.get(rid)
            for i in range(len(stops_seq) - 1):
                sid_a, measure_a, pt_a = stops_seq[i]
                sid_b, measure_b, pt_b = stops_seq[i + 1]
                seg_len = QgsGeometry.fromPolylineXY([pt_a, pt_b]).length()
                track_speed = self._estimate_segment_speed_from_tracks(rid, measure_a, measure_b, track_segments_by_route)
                if track_speed and track_speed > 0:
                    seg_time = seg_len / track_speed
                elif tt_route and tt_route > 0 and total_len > 0:
                    seg_time = tt_route * (seg_len / total_len)
                else:
                    seg_time = seg_len / bus_speed_mps
                edges[node_index[sid_a]].append((node_index[sid_b], seg_time, 'bus'))

        # Пересадки
        s_index = QgsSpatialIndex(stops_points.getFeatures())
        for stop_id, pt in stop_pts:
            bbox = QgsGeometry.fromPointXY(pt).buffer(transfer_dist, 6).boundingBox()
            cand_ids = s_index.intersects(bbox)
            for sid2 in cand_ids:
                if sid2 == stop_id or sid2 not in node_index:
                    continue
                pt2 = stop_id_to_geom.get(sid2)
                if pt2 is None:
                    continue
                d = QgsGeometry.fromPointXY(pt).distance(QgsGeometry.fromPointXY(pt2))
                if d > transfer_dist:
                    continue
                candidate_routes2 = [rid for rid, arr in stops_route_map.items() if any(sid == sid2 for sid, _, _ in arr)]
                waits2 = [route_headway.get(rid, 600) for rid in candidate_routes2 if route_headway.get(rid)]
                wait2 = min(waits2) / 2.0 if waits2 else 300.0
                walk_sec = self._compute_transfer_walk_time(stop_id, sid2, stop_node_info, edges_by_node,
                                                            walk_speed_mps, transfer_dist, d)
                total_transfer = walk_sec + wait2
                edges[node_index[stop_id]].append((node_index[sid2], total_transfer, 'transfer'))

        total_edges = sum(len(v) for v in edges.values())
        feedback.pushInfo(f" Мультиграф: узлов={len(nodes)}, рёбер={total_edges}")

        # --- Шаг 10: Dijkstra по мультиграфу ---
        feedback.pushInfo(" Запуск Dijkstra по мультиграфу...")
        N = len(nodes)
        dist = [math.inf] * N
        prev = [None] * N
        dist[0] = 0.0
        heap = [(0.0, 0)]
        visited = [False] * N
        pops = 0

        t_dij = time.time()
        while heap:
            d_u, u = heapq.heappop(heap)
            pops += 1
            if visited[u]:
                continue
            visited[u] = True
            if d_u > dist[u]:
                continue
            for (v, w, etype) in edges.get(u, []):
                nd = d_u + w
                if nd < dist[v]:
                    dist[v] = nd
                    prev[v] = u
                    heapq.heappush(heap, (nd, v))
        feedback.pushInfo(f"    Dijkstra завершён: {pops} извлечений, за {time.time() - t_dij:.2f}s")

        # --- Шаг 11: Сбор достижимых точек для каждого шага ---
        reachable_points_by_step = {step: [] for step in range(1, steps + 1)}

        # Пешие точки (ручной граф)
        if not fallback_mode and dist_walk is not None:
            for step in range(1, steps + 1):
                max_t = time_interval * step * 60.0
                for key, t_val in dist_walk.items():
                    if t_val < max_t and t_val != math.inf:
                        reachable_points_by_step[step].append(node_coords[key])

        # Остановки (транспорт)
        for v in range(1, N):
            t = dist[v]
            if t == math.inf:
                continue
            for step in range(1, steps + 1):
                if t <= time_interval * step * 60.0:
                    reachable_points_by_step[step].append(nodes[v])
                    break

        # --- Шаг 12: ПОСТРОЕНИЕ ИЗОХРОН ЧЕРЕЗ ВЫПУКЛУЮ ОБОЛОЧКУ (ручной способ, QGIS 3.44+ совместим) ---
        feedback.pushInfo("Построение выпуклых оболочек вручную (без processing.run)...")

        fields = QgsFields()
        fields.append(QgsField("minutes", QVariant.Int))
        fields.append(QgsField("area_m2", QVariant.Double))
        fields.append(QgsField("population", QVariant.Double))

        # Создаём sink (с fallback на memory-слой)
        sink = None
        dest_id = None
        try:
            sink_result = self.parameterAsSink(parameters, self.OUTPUT, context, fields, QgsWkbTypes.MultiPolygon, crs)
            if isinstance(sink_result, tuple):
                sink, dest_id = sink_result
            else:
                sink, dest_id = sink_result, None
        except Exception as e:
            feedback.pushInfo(f" parameterAsSink: {e}. Создаю memory-слой.")

        if sink is None:
            mem_layer = QgsVectorLayer(f"MultiPolygon?crs={crs.authid()}", "Изохроны (convex hull)", "memory")
            prov = mem_layer.dataProvider()
            prov.addAttributes(fields)
            mem_layer.updateFields()
            QgsProject.instance().addMapLayer(mem_layer)
            sink = prov
            dest_id = mem_layer.id()

        total_created = 0
        for step in range(1, steps + 1):
            points = reachable_points_by_step[step]
            if len(points) < 3:
                feedback.pushInfo(f"  Шаг {step}: недостаточно точек ({len(points)}) для convex hull")
                continue

            try:
                # Создаём MultiPoint из всех достижимых точек
                qgs_points = [QgsPointXY(p.x(), p.y()) for p in points]
                multi_pt = QgsGeometry.fromMultiPointXY(qgs_points)
                hull_geom = multi_pt.convexHull()

                if hull_geom is None or hull_geom.isEmpty() or hull_geom.type() != QgsWkbTypes.PolygonGeometry:
                    raise Exception("convexHull() не вернул полигон")

            except Exception as e:
                feedback.reportError(f"   Ошибка при построении hull для шага {step}: {e}")
                continue

            # Подсчёт населения
            population = 0.0
            bbox = hull_geom.boundingBox()
            candidate_ids = b_index.intersects(bbox)
            req = QgsFeatureRequest().setFilterFids(candidate_ids)
            for b_feat in buildings_reproj.getFeatures(req):
                b_geom = b_feat.geometry()
                if not b_geom or not b_geom.intersects(hull_geom):
                    continue
                pop_val = b_feat.attribute('Насел')
                if pop_val is None:
                    continue
                try:
                    if isinstance(pop_val, str):
                        pop_val = float(pop_val.strip().replace(',', '.'))
                    population += float(pop_val)
                except (ValueError, TypeError):
                    pass

            # Создание фичи
            feat = QgsFeature()
            feat.setGeometry(hull_geom)
            feat.setFields(fields)
            minutes = int(round(step * time_interval))
            feat.setAttributes([minutes, hull_geom.area(), round(population, 1)])

            try:
                sink.addFeature(feat, QgsFeatureSink.FastInsert)
                total_created += 1
                feedback.pushInfo(f"   Шаг {step} ({minutes} мин): площадь = {hull_geom.area():.0f} м², население = {population:.1f}")
            except Exception as e:
                feedback.reportError(f"   Не удалось сохранить изохрону шага {step}: {e}")

        elapsed = time.time() - t_total
        feedback.pushInfo(f" Этап 3 (convex hull, финал): создано {total_created} СПЛОШНЫХ изохрон за {elapsed:.1f} сек")
        return {self.OUTPUT: dest_id}
